Description: Fix heap overflow vulnerability.
 openslp has a heap overflow vulnerability that when exploited may result
 in memory corruption and a crash of slpd or in remote code execution.
 .
 VMware would like to thank the 360Vulcan team working with the 2019
 Tianfu Cup Pwn Contest for reporting this issue to us.
Author: VMware Security Response Center
Author: Utkarsh Gupta <guptautkarsh2102@gmail.com>
Origin: https://www.openwall.com/lists/oss-security/2019/12/06/1
Last-Update: 2019-12-07

--- a/common/slp_buffer.c
+++ b/common/slp_buffer.c
@@ -47,6 +47,12 @@
 /*                                                                         */
 /***************************************************************************/
 
+/* Copyright (c) 2019 VMware, Inc.
+ * SPDX-License-Identifier: BSD-3-Clause
+ * This file is provided under the BSD-3-Clause license.
+ * See COPYING file for more details and other copyrights
+ * that may apply.
+ */
 
 #include "slp_buffer.h" 
 #include "slp_xmalloc.h"
@@ -142,6 +148,21 @@
     return result;
 }
 
+/*=========================================================================*/
+size_t RemainingBufferSpace(SLPBuffer buf)
+/* Report remaining free buffer size in bytes.                             */
+/*                                                                         */
+/* Check if buffer is allocated and if so return bytes left in a           */
+/* @c SLPBuffer object.                                                    */
+/*                                                                         */
+/* @param[in] buf The SLPBuffer to be freed.                               */
+/*=========================================================================*/
+{
+   if (buf->allocated == 0) {
+      return 0;
+   }
+   return buf->end - buf->curpos;
+}
 
 /*=========================================================================*/
 SLPBuffer SLPBufferDup(SLPBuffer buf)
--- a/common/slp_buffer.h
+++ b/common/slp_buffer.h
@@ -48,6 +48,13 @@
 /*                                                                         */
 /***************************************************************************/
 
+/* Copyright (c) 2019 VMware, Inc.
+ * SPDX-License-Identifier: BSD-3-Clause
+ * This file is provided under the BSD-3-Clause license.
+ * See COPYING file for more details and other copyrights
+ * that may apply.
+ */
+
 #if(!defined SLP_BUFFER_H_INCLUDED)
 #define SLP_BUFFER_H_INCLUDED
 
@@ -147,6 +154,15 @@
 /* Returns the added item in the list.                                     */
 /*=========================================================================*/
 
+size_t RemainingBufferSpace(SLPBuffer buf);
+/*=========================================================================*/
+/* Return bytes left in buffer from current position                       */
+/*                                                                         */
+/* buf (IN) pointer to the buffer                                          */
+/*                                                                         */
+/* Returns number of bytes left in buffer from current position            */
+/*=========================================================================*/
+
 
 /*=========================================================================*/
 void* memdup(const void* src, int srclen);
--- a/slpd/slpd_process.c
+++ b/slpd/slpd_process.c
@@ -46,6 +46,13 @@
 /*                                                                         */
 /***************************************************************************/
 
+/* Copyright (c) 2019 VMware, Inc.
+ * SPDX-License-Identifier: BSD-3-Clause
+ * This file is provided under the BSD-3-Clause license.
+ * See COPYING file for more details and other copyrights
+ * that may apply.
+ */
+
 /*=========================================================================*/
 /* slpd includes                                                           */
 /*=========================================================================*/
@@ -456,11 +463,26 @@
         {
             /* urlentry is the url from the db result */
             urlentry = db->urlarray[i];
-
+            if (urlentry->opaque != NULL)
+            {
+                const int64_t newsize = size + urlentry->opaquelen;
+                if (urlentry->opaquelen <= 0 || newsize > INT_MAX)
+                {
+                    SLPDLog("Invalid opaquelen %d or sizeo of opaque url is too big, size=%d\n",
+                            urlentry->opaquelen, size);
+                    errorcode = SLP_ERROR_PARSE_ERROR;
+                    goto FINISHED;
+                }
+            size +=  urlentry->opaquelen;
+         }
+         else
+         {
+            /* urlentry is the url from the db result */
             size += urlentry->urllen + 6; /*  1 byte for reserved  */
                                           /*  2 bytes for lifetime */
                                           /*  2 bytes for urllen   */
                                           /*  1 byte for authcount */
+          }
 #ifdef ENABLE_SLPv2_SECURITY
 
             /* make room to include the authblock that was asked for */
@@ -536,7 +558,7 @@
             urlentry = db->urlarray[i]; 
 
 #ifdef ENABLE_SLPv1
-            if (urlentry->opaque == 0)
+            if (urlentry->opaque == NULL)
             {
                 /* url-entry reserved */
                 *result->curpos = 0;        
@@ -548,8 +570,18 @@
                 ToUINT16(result->curpos,urlentry->urllen);
                 result->curpos = result->curpos + 2;
                 /* url-entry url */
-                memcpy(result->curpos,urlentry->url,urlentry->urllen);
-                result->curpos = result->curpos + urlentry->urllen;
+                if (RemainingBufferSpace(result) >= urlentry->urllen)
+                {
+                   memcpy(result->curpos, urlentry->url, urlentry->urllen);
+                   result->curpos = result->curpos + urlentry->urllen;
+                }
+                else
+                {
+                   SLPDLog("Url too big (ask: %d have %lld), failing request\n",
+                           urlentry->opaquelen, (long long) RemainingBufferSpace(result));
+                   errorcode = SLP_ERROR_PARSE_ERROR;
+                   goto FINISHED;
+                }
                 /* url-entry auths */
                 *result->curpos = 0;
                 result->curpos = result->curpos + 1;
@@ -560,8 +592,18 @@
                 /* Use an opaque copy if available (and authentication is not being used)*/
                 /* TRICKY: fix up the lifetime */
                 ToUINT16(urlentry->opaque + 1,urlentry->lifetime);
-                memcpy(result->curpos,urlentry->opaque,urlentry->opaquelen);
-                result->curpos = result->curpos + urlentry->opaquelen;
+                if (RemainingBufferSpace(result) >= urlentry->opaquelen)
+                {
+                   memcpy(result->curpos, urlentry->opaque, urlentry->opaquelen);
+                   result->curpos = result->curpos + urlentry->opaquelen;
+                }
+                else
+                {
+                   SLPDLog("Opaque Url too big (ask: %d have %lld), failing request\n",
+                           urlentry->opaquelen, (long long) RemainingBufferSpace(result));
+                   errorcode = SLP_ERROR_PARSE_ERROR;
+                   goto FINISHED;
+                }
             }
         }
     }
